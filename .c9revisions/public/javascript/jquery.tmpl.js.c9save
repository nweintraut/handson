{"ts":1372913963736,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n * jQuery Templating Plugin\n * Copyright 2010, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n */\n(function( jQuery, undefined ){\n\tvar oldManip = jQuery.fn.domManip, tmplItmAtt = \"_tmplitem\", htmlExpr = /^[^<]*(<[\\w\\W]+>)[^>]*$|\\{\\{\\! /,\n\t\tnewTmplItems = {}, wrappedItems = {}, appendToTmplItems, topTmplItem = { key: 0, data: {} }, itemKey = 0, cloneIndex = 0, stack = [];\n\n\tfunction newTmplItem( options, parentItem, fn, data ) {\n\t\t// Returns a template item data structure for a new rendered instance of a template (a 'template item').\n\t\t// The content field is a hierarchical array of strings and nested items (to be\n\t\t// removed and replaced by nodes field of dom elements, once inserted in DOM).\n\t\tvar newItem = {\n\t\t\tdata: data || (parentItem ? parentItem.data : {}),\n\t\t\t_wrap: parentItem ? parentItem._wrap : null,\n\t\t\ttmpl: null,\n\t\t\tparent: parentItem || null,\n\t\t\tnodes: [],\n\t\t\tcalls: tiCalls,\n\t\t\tnest: tiNest,\n\t\t\twrap: tiWrap,\n\t\t\thtml: tiHtml,\n\t\t\tupdate: tiUpdate\n\t\t};\n\t\tif ( options ) {\n\t\t\tjQuery.extend( newItem, options, { nodes: [], parent: parentItem } );\n\t\t}\n\t\tif ( fn ) {\n\t\t\t// Build the hierarchical content to be used during insertion into DOM\n\t\t\tnewItem.tmpl = fn;\n\t\t\tnewItem._ctnt = newItem._ctnt || newItem.tmpl( jQuery, newItem );\n\t\t\tnewItem.key = ++itemKey;\n\t\t\t// Keep track of new template item, until it is stored as jQuery Data on DOM element\n\t\t\t(stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;\n\t\t}\n\t\treturn newItem;\n\t}\n\n\t// Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).\n\tjQuery.each({\n\t\tappendTo: \"append\",\n\t\tprependTo: \"prepend\",\n\t\tinsertBefore: \"before\",\n\t\tinsertAfter: \"after\",\n\t\treplaceAll: \"replaceWith\"\n\t}, function( name, original ) {\n\t\tjQuery.fn[ name ] = function( selector ) {\n\t\t\tvar ret = [], insert = jQuery( selector ), elems, i, l, tmplItems,\n\t\t\t\tparent = this.length === 1 && this[0].parentNode;\n\n\t\t\tappendToTmplItems = newTmplItems || {};\n\t\t\tif ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {\n\t\t\t\tinsert[ original ]( this[0] );\n\t\t\t\tret = this;\n\t\t\t} else {\n\t\t\t\tfor ( i = 0, l = insert.length; i < l; i++ ) {\n\t\t\t\t\tcloneIndex = i;\n\t\t\t\t\telems = (i > 0 ? this.clone(true) : this).get();\n\t\t\t\t\tjQuery.fn[ original ].apply( jQuery(insert[i]), elems );\n\t\t\t\t\tret = ret.concat( elems );\n\t\t\t\t}\n\t\t\t\tcloneIndex = 0;\n\t\t\t\tret = this.pushStack( ret, name, insert.selector );\n\t\t\t}\n\t\t\ttmplItems = appendToTmplItems;\n\t\t\tappendToTmplItems = null;\n\t\t\tjQuery.tmpl.complete( tmplItems );\n\t\t\treturn ret;\n\t\t};\n\t});\n\n\tjQuery.fn.extend({\n\t\t// Use first wrapped element as template markup.\n\t\t// Return wrapped set of template items, obtained by rendering template against data.\n\t\ttmpl: function( data, options, parentItem ) {\n\t\t\treturn jQuery.tmpl( this[0], data, options, parentItem );\n\t\t},\n\n\t\t// Find which rendered template item the first wrapped DOM element belongs to\n\t\ttmplItem: function() {\n\t\t\treturn jQuery.tmplItem( this[0] );\n\t\t},\n\n\t\t// Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.\n\t\ttemplate: function( name ) {\n\t\t\treturn jQuery.template( name, this[0] );\n\t\t},\n\n\t\tdomManip: function( args, table, callback, options ) {\n\t\t\t// This appears to be a bug in the appendTo, etc. implementation\n\t\t\t// it should be doing .call() instead of .apply(). See #6227\n\t\t\tif ( args[0] && args[0].nodeType ) {\n\t\t\t\tvar dmArgs = jQuery.makeArray( arguments ), argsLength = args.length, i = 0, tmplItem;\n\t\t\t\twhile ( i < argsLength && !(tmplItem = jQuery.data( args[i++], \"tmplItem\" ))) {}\n\t\t\t\tif ( argsLength > 1 ) {\n\t\t\t\t\tdmArgs[0] = [jQuery.makeArray( args )];\n\t\t\t\t}\n\t\t\t\tif ( tmplItem && cloneIndex ) {\n\t\t\t\t\tdmArgs[2] = function( fragClone ) {\n\t\t\t\t\t\t// Handler called by oldManip when rendered template has been inserted into DOM.\n\t\t\t\t\t\tjQuery.tmpl.afterManip( this, fragClone, callback );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\toldManip.apply( this, dmArgs );\n\t\t\t} else {\n\t\t\t\toldManip.apply( this, arguments );\n\t\t\t}\n\t\t\tcloneIndex = 0;\n\t\t\tif ( !appendToTmplItems ) {\n\t\t\t\tjQuery.tmpl.complete( newTmplItems );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\t// Return wrapped set of template items, obtained by rendering template against data.\n\t\ttmpl: function( tmpl, data, options, parentItem ) {\n\t\t\tvar ret, topLevel = !parentItem;\n\t\t\tif ( topLevel ) {\n\t\t\t\t// This is a top-level tmpl call (not from a nested template using {{tmpl}})\n\t\t\t\tparentItem = topTmplItem;\n\t\t\t\ttmpl = jQuery.template[tmpl] || jQuery.template( null, tmpl );\n\t\t\t\twrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level\n\t\t\t} else if ( !tmpl ) {\n\t\t\t\t// The template item is already associated with DOM - this is a refresh.\n\t\t\t\t// Re-evaluate rendered template for the parentItem\n\t\t\t\ttmpl = parentItem.tmpl;\n\t\t\t\tnewTmplItems[parentItem.key] = parentItem;\n\t\t\t\tparentItem.nodes = [];\n\t\t\t\tif ( parentItem.wrapped ) {\n\t\t\t\t\tupdateWrapped( parentItem, parentItem.wrapped );\n\t\t\t\t}\n\t\t\t\t// Rebuild, without creating a new template item\n\t\t\t\treturn jQuery( build( parentItem, null, parentItem.tmpl( jQuery, parentItem ) ));\n\t\t\t}\n\t\t\tif ( !tmpl ) {\n\t\t\t\treturn []; // Could throw...\n\t\t\t}\n\t\t\tif ( typeof data === \"function\" ) {\n\t\t\t\tdata = data.call( parentItem || {} );\n\t\t\t}\n\t\t\tif ( options && options.wrapped ) {\n\t\t\t\tupdateWrapped( options, options.wrapped );\n\t\t\t}\n\t\t\tret = jQuery.isArray( data ) ? \n\t\t\t\tjQuery.map( data, function( dataItem ) {\n\t\t\t\t\treturn dataItem ? newTmplItem( options, parentItem, tmpl, dataItem ) : null;\n\t\t\t\t}) :\n\t\t\t\t[ newTmplItem( options, parentItem, tmpl, data ) ];\n\t\t\treturn topLevel ? jQuery( build( parentItem, null, ret ) ) : ret;\n\t\t},\n\n\t\t// Return rendered template item for an element.\n\t\ttmplItem: function( elem ) {\n\t\t\tvar tmplItem;\n\t\t\tif ( elem instanceof jQuery ) {\n\t\t\t\telem = elem[0];\n\t\t\t}\n\t\t\twhile ( elem && elem.nodeType === 1 && !(tmplItem = jQuery.data( elem, \"tmplItem\" )) && (elem = elem.parentNode) ) {}\n\t\t\treturn tmplItem || topTmplItem;\n\t\t},\n\n\t\t// Set:\n\t\t// Use $.template( name, tmpl ) to cache a named template,\n\t\t// where tmpl is a template string, a script element or a jQuery instance wrapping a script element, etc.\n\t\t// Use $( \"selector\" ).template( name ) to provide access by name to a script block template declaration.\n\n\t\t// Get:\n\t\t// Use $.template( name ) to access a cached template.\n\t\t// Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )\n\t\t// will return the compiled template, without adding a name reference.\n\t\t// If templateString includes at least one HTML tag, $.template( templateString ) is equivalent\n\t\t// to $.template( null, templateString )\n\t\ttemplate: function( name, tmpl ) {\n\t\t\tif (tmpl) {\n\t\t\t\t// Compile template and associate with name\n\t\t\t\tif ( typeof tmpl === \"string\" ) {\n\t\t\t\t\t// This is an HTML string being passed directly in.\n\t\t\t\t\ttmpl = buildTmplFn( tmpl )\n\t\t\t\t} else if ( tmpl instanceof jQuery ) {\n\t\t\t\t\ttmpl = tmpl[0] || {};\n\t\t\t\t}\n\t\t\t\tif ( tmpl.nodeType ) {\n\t\t\t\t\t// If this is a template block, use cached copy, or generate tmpl function and cache.\n\t\t\t\t\ttmpl = jQuery.data( tmpl, \"tmpl\" ) || jQuery.data( tmpl, \"tmpl\", buildTmplFn( tmpl.innerHTML ));\n\t\t\t\t}\n\t\t\t\treturn typeof name === \"string\" ? (jQuery.template[name] = tmpl) : tmpl;\n\t\t\t}\n\t\t\t// Return named compiled template\n\t\t\treturn name ? (typeof name !== \"string\" ? jQuery.template( null, name ): \n\t\t\t\t(jQuery.template[name] || \n\t\t\t\t\t// If not in map, treat as a selector. (If integrated with core, use quickExpr.exec) \n\t\t\t\t\tjQuery.template( null, htmlExpr.test( name ) ? name : jQuery( name )))) : null; \n\t\t},\n\n\t\tencode: function( text ) {\n\t\t\t// Do HTML encoding replacing < > & and ' and \" by corresponding entities.\n\t\t\treturn (\"\" + text).split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\").split('\"').join(\"&#34;\").split(\"'\").join(\"&#39;\");\n\t\t}\n\t});\n\n\tjQuery.extend( jQuery.tmpl, {\n\t\ttag: {\n\t\t\t\"tmpl\": {\n\t\t\t\t_default: { $2: \"null\" },\n\t\t\t\topen: \"if($notnull_1){_=_.concat($item.nest($1,$2));}\"\n\t\t\t\t// tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)\n\t\t\t\t// This means that {{tmpl foo}} treats foo as a template (which IS a function). \n\t\t\t\t// Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.\n\t\t\t},\n\t\t\t\"wrap\": {\n\t\t\t\t_default: { $2: \"null\" },\n\t\t\t\topen: \"$item.calls(_,$1,$2);_=[];\",\n\t\t\t\tclose: \"call=$item.calls();_=call._.concat($item.wrap(call,_));\"\n\t\t\t},\n\t\t\t\"each\": {\n\t\t\t\t_default: { $2: \"$index, $value\" },\n\t\t\t\topen: \"if($notnull_1){$.each($1a,function($2){with(this){\",\n\t\t\t\tclose: \"}});}\"\n\t\t\t},\n\t\t\t\"if\": {\n\t\t\t\topen: \"if(($notnull_1) && $1a){\",\n\t\t\t\tclose: \"}\"\n\t\t\t},\n\t\t\t\"else\": {\n\t\t\t\t_default: { $1: \"true\" },\n\t\t\t\topen: \"}else if(($notnull_1) && $1a){\"\n\t\t\t},\n\t\t\t\"html\": {\n\t\t\t\t// Unecoded expression evaluation. \n\t\t\t\topen: \"if($notnull_1){_.push($1a);}\"\n\t\t\t},\n\t\t\t\"=\": {\n\t\t\t\t// Encoded expression evaluation. Abbreviated form is ${}.\n\t\t\t\t_default: { $1: \"$data\" },\n\t\t\t\topen: \"if($notnull_1){_.push($.encode($1a));}\"\n\t\t\t},\n\t\t\t\"!\": {\n\t\t\t\t// Comment tag. Skipped by parser\n\t\t\t\topen: \"\"\n\t\t\t}\n\t\t},\n\n\t\t// This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events\n\t\tcomplete: function( items ) {\n\t\t\tnewTmplItems = {};\n\t\t},\n\n\t\t// Call this from code which overrides domManip, or equivalent\n\t\t// Manage cloning/storing template items etc.\n\t\tafterManip: function afterManip( elem, fragClone, callback ) {\n\t\t\t// Provides cloned fragment ready for fixup prior to and after insertion into DOM\n\t\t\tvar content = fragClone.nodeType === 11 ?\n\t\t\t\tjQuery.makeArray(fragClone.childNodes) :\n\t\t\t\tfragClone.nodeType === 1 ? [fragClone] : [];\n\n\t\t\t// Return fragment to original caller (e.g. append) for DOM insertion\n\t\t\tcallback.call( elem, fragClone );\n\n\t\t\t// Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by jQuery.data.\n\t\t\tstoreTmplItems( content );\n\t\t\tcloneIndex++;\n\t\t}\n\t});\n\n\t//========================== Private helper functions, used by code above ==========================\n\n\tfunction build( tmplItem, nested, content ) {\n\t\t// Convert hierarchical content into flat string array \n\t\t// and finally return array of fragments ready for DOM insertion\n\t\tvar frag, ret = content ? jQuery.map( content, function( item ) {\n\t\t\treturn (typeof item === \"string\") ? \n\t\t\t\t// Insert template item annotations, to be converted to jQuery.data( \"tmplItem\" ) when elems are inserted into DOM.\n\t\t\t\t(tmplItem.key ? item.replace( /(<\\w+)(?=[\\s>])(?![^>]*_tmplitem)([^>]*)/g, \"$1 \" + tmplItmAtt + \"=\\\"\" + tmplItem.key + \"\\\" $2\" ) : item) :\n\t\t\t\t// This is a child template item. Build nested template.\n\t\t\t\tbuild( item, tmplItem, item._ctnt );\n\t\t}) : \n\t\t// If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}. \n\t\ttmplItem;\n\t\tif ( nested ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t// top-level template\n\t\tret = ret.join(\"\");\n\n\t\t// Support templates which have initial or final text nodes, or consist only of text\n\t\t// Also support HTML entities within the HTML markup.\n\t\tret.replace( /^\\s*([^<\\s][^<]*)?(<[\\w\\W]+>)([^>]*[^>\\s])?\\s*$/, function( all, before, middle, after) {\n\t\t\tfrag = jQuery( middle ).get();\n\n\t\t\tstoreTmplItems( frag );\n\t\t\tif ( before ) {\n\t\t\t\tfrag = unencode( before ).concat(frag);\n\t\t\t}\n\t\t\tif ( after ) {\n\t\t\t\tfrag = frag.concat(unencode( after ));\n\t\t\t}\n\t\t});\n\t\treturn frag ? frag : unencode( ret );\n\t}\n\n\tfunction unencode( text ) {\n\t\t// Use createElement, since createTextNode will not render HTML entities correctly\n\t\tvar el = document.createElement( \"div\" );\n\t\tel.innerHTML = text;\n\t\treturn jQuery.makeArray(el.childNodes);\n\t}\n\n\t// Generate a reusable function that will serve to render a template against data\n\tfunction buildTmplFn( markup ) {\n\t\treturn new Function(\"jQuery\",\"$item\",\n\t\t\t\"var $=jQuery,call,_=[],$data=$item.data;\" +\n\n\t\t\t// Introduce the data as local variables using with(){}\n\t\t\t\"with($data){_.push('\" +\n\n\t\t\t// Convert the template into pure JavaScript\n\t\t\tjQuery.trim(markup)\n\t\t\t\t.replace( /([\\\\'])/g, \"\\\\$1\" )\n\t\t\t\t.replace( /[\\r\\t\\n]/g, \" \" )\n\t\t\t\t.replace( /\\$\\{([^\\}]*)\\}/g, \"{{= $1}}\" )\n\t\t\t\t.replace( /\\{\\{(\\/?)(\\w+|.)(?:\\(((?:[^\\}]|\\}(?!\\}))*?)?\\))?(?:\\s+(.*?)?)?(\\(((?:[^\\}]|\\}(?!\\}))*?)\\))?\\s*\\}\\}/g,\n\t\t\t\tfunction( all, slash, type, fnargs, target, parens, args ) {\n\t\t\t\t\tvar tag = jQuery.tmpl.tag[ type ], def, expr, exprAutoFnDetect;\n\t\t\t\t\tif ( !tag ) {\n\t\t\t\t\t\tthrow \"Template command not found: \" + type;\n\t\t\t\t\t}\n\t\t\t\t\tdef = tag._default || [];\n\t\t\t\t\tif ( parens && !/\\w$/.test(target)) {\n\t\t\t\t\t\ttarget += parens;\n\t\t\t\t\t\tparens = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif ( target ) {\n\t\t\t\t\t\ttarget = unescape( target ); \n\t\t\t\t\t\targs = args ? (\",\" + unescape( args ) + \")\") : (parens ? \")\" : \"\");\n\t\t\t\t\t\t// Support for target being things like a.toLowerCase();\n\t\t\t\t\t\t// In that case don't call with template item as 'this' pointer. Just evaluate...\n\t\t\t\t\t\texpr = parens ? (target.indexOf(\".\") > -1 ? target + parens : (\"(\" + target + \").call($item\" + args)) : target;\n\t\t\t\t\t\texprAutoFnDetect = parens ? expr : \"(typeof(\" + target + \")==='function'?(\" + target + \").call($item):(\" + target + \"))\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\texprAutoFnDetect = expr = def.$1 || \"null\";\n\t\t\t\t\t}\n\t\t\t\t\tfnargs = unescape( fnargs );\n\t\t\t\t\treturn \"');\" + \n\t\t\t\t\t\ttag[ slash ? \"close\" : \"open\" ]\n\t\t\t\t\t\t\t.split( \"$notnull_1\" ).join( target ? \"typeof(\" + target + \")!=='undefined' && (\" + target + \")!=null\" : \"true\" )\n\t\t\t\t\t\t\t.split( \"$1a\" ).join( exprAutoFnDetect )\n\t\t\t\t\t\t\t.split( \"$1\" ).join( expr )\n\t\t\t\t\t\t\t.split( \"$2\" ).join( fnargs ?\n\t\t\t\t\t\t\t\tfnargs.replace( /\\s*([^\\(]+)\\s*(\\((.*?)\\))?/g, function( all, name, parens, params ) {\n\t\t\t\t\t\t\t\t\tparams = params ? (\",\" + params + \")\") : (parens ? \")\" : \"\");\n\t\t\t\t\t\t\t\t\treturn params ? (\"(\" + name + \").call($item\" + params) : all;\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t: (def.$2||\"\")\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\"_.push('\";\n\t\t\t\t}) +\n\t\t\t\"');}return _;\"\n\t\t);\n\t}\n\tfunction updateWrapped( options, wrapped ) {\n\t\t// Build the wrapped content. \n\t\toptions._wrap = build( options, true, \n\t\t\t// Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.\n\t\t\tjQuery.isArray( wrapped ) ? wrapped : [htmlExpr.test( wrapped ) ? wrapped : jQuery( wrapped ).html()]\n\t\t).join(\"\");\n\t}\n\n\tfunction unescape( args ) {\n\t\treturn args ? args.replace( /\\\\'/g, \"'\").replace(/\\\\\\\\/g, \"\\\\\" ) : null;\n\t}\n\tfunction outerHtml( elem ) {\n\t\tvar div = document.createElement(\"div\");\n\t\tdiv.appendChild( elem.cloneNode(true) );\n\t\treturn div.innerHTML;\n\t}\n\n\t// Store template items in jQuery.data(), ensuring a unique tmplItem data data structure for each rendered template instance.\n\tfunction storeTmplItems( content ) {\n\t\tvar keySuffix = \"_\" + cloneIndex, elem, elems, newClonedItems = {}, i, l, m;\n\t\tfor ( i = 0, l = content.length; i < l; i++ ) {\n\t\t\tif ( (elem = content[i]).nodeType !== 1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telems = elem.getElementsByTagName(\"*\");\n\t\t\tfor ( m = elems.length - 1; m >= 0; m-- ) {\n\t\t\t\tprocessItemKey( elems[m] );\n\t\t\t}\n\t\t\tprocessItemKey( elem );\n\t\t}\n\t\tfunction processItemKey( el ) {\n\t\t\tvar pntKey, pntNode = el, pntItem, tmplItem, key;\n\t\t\t// Ensure that each rendered template inserted into the DOM has its own template item,\n\t\t\tif ( (key = el.getAttribute( tmplItmAtt ))) {\n\t\t\t\twhile ( pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute( tmplItmAtt ))) { }\n\t\t\t\tif ( pntKey !== key ) {\n\t\t\t\t\t// The next ancestor with a _tmplitem expando is on a different key than this one.\n\t\t\t\t\t// So this is a top-level element within this template item\n\t\t\t\t\t// Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.\n\t\t\t\t\tpntNode = pntNode.parentNode ? (pntNode.nodeType === 11 ? 0 : (pntNode.getAttribute( tmplItmAtt ) || 0)) : 0;\n\t\t\t\t\tif ( !(tmplItem = newTmplItems[key]) ) {\n\t\t\t\t\t\t// The item is for wrapped content, and was copied from the temporary parent wrappedItem.\n\t\t\t\t\t\ttmplItem = wrappedItems[key];\n\t\t\t\t\t\ttmplItem = newTmplItem( tmplItem, newTmplItems[pntNode]||wrappedItems[pntNode], null, true );\n\t\t\t\t\t\ttmplItem.key = ++itemKey;\n\t\t\t\t\t\tnewTmplItems[itemKey] = tmplItem;\n\t\t\t\t\t}\n\t\t\t\t\tif ( cloneIndex ) {\n\t\t\t\t\t\tcloneTmplItem( key );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tel.removeAttribute( tmplItmAtt );\n\t\t\t} else if ( cloneIndex && (tmplItem = jQuery.data( el, \"tmplItem\" )) ) {\n\t\t\t\t// This was a rendered element, cloned during append or appendTo etc.\n\t\t\t\t// TmplItem stored in jQuery data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.\n\t\t\t\tcloneTmplItem( tmplItem.key );\n\t\t\t\tnewTmplItems[tmplItem.key] = tmplItem;\n\t\t\t\tpntNode = jQuery.data( el.parentNode, \"tmplItem\" );\n\t\t\t\tpntNode = pntNode ? pntNode.key : 0;\n\t\t\t}\n\t\t\tif ( tmplItem ) {\n\t\t\t\tpntItem = tmplItem;\n\t\t\t\t// Find the template item of the parent element. \n\t\t\t\t// (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)\n\t\t\t\twhile ( pntItem && pntItem.key != pntNode ) { \n\t\t\t\t\t// Add this element as a top-level node for this rendered template item, as well as for any\n\t\t\t\t\t// ancestor items between this item and the item of its parent element\n\t\t\t\t\tpntItem.nodes.push( el );\n\t\t\t\t\tpntItem = pntItem.parent;\n\t\t\t\t}\n\t\t\t\t// Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...\n\t\t\t\tdelete tmplItem._ctnt;\n\t\t\t\tdelete tmplItem._wrap;\n\t\t\t\t// Store template item as jQuery data on the element\n\t\t\t\tjQuery.data( el, \"tmplItem\", tmplItem );\n\t\t\t}\n\t\t\tfunction cloneTmplItem( key ) {\n\t\t\t\tkey = key + keySuffix;\n\t\t\t\ttmplItem = newClonedItems[key] = \n\t\t\t\t\t(newClonedItems[key] || newTmplItem( tmplItem, newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent, null, true ));\n\t\t\t}\n\t\t}\n\t}\n\n\t//---- Helper functions for template item ----\n\n\tfunction tiCalls( content, tmpl, data, options ) {\n\t\tif ( !content ) {\n\t\t\treturn stack.pop();\n\t\t}\n\t\tstack.push({ _: content, tmpl: tmpl, item:this, data: data, options: options });\n\t}\n\n\tfunction tiNest( tmpl, data, options ) {\n\t\t// nested template, using {{tmpl}} tag\n\t\treturn jQuery.tmpl( jQuery.template( tmpl ), data, options, this );\n\t}\n\n\tfunction tiWrap( call, wrapped ) {\n\t\t// nested template, using {{wrap}} tag\n\t\tvar options = call.options || {};\n\t\toptions.wrapped = wrapped;\n\t\t// Apply the template, which may incorporate wrapped content, \n\t\treturn jQuery.tmpl( jQuery.template( call.tmpl ), call.data, options, call.item );\n\t}\n\n\tfunction tiHtml( filter, textOnly ) {\n\t\tvar wrapped = this._wrap;\n\t\treturn jQuery.map(\n\t\t\tjQuery( jQuery.isArray( wrapped ) ? wrapped.join(\"\") : wrapped ).filter( filter || \"*\" ),\n\t\t\tfunction(e) {\n\t\t\t\treturn textOnly ?\n\t\t\t\t\te.innerText || e.textContent :\n\t\t\t\t\te.outerHTML || outerHtml(e);\n\t\t\t});\n\t}\n\n\tfunction tiUpdate() {\n\t\tvar coll = this.nodes;\n\t\tjQuery.tmpl( null, null, null, this).insertBefore( coll[0] );\n\t\tjQuery( coll ).remove();\n\t}\n})( jQuery );\n"]],"start1":0,"start2":0,"length1":0,"length2":18839}]],"length":18839}
